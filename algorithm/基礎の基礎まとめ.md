## .each


.each メソッドは Ruby において非常に重要な役割を果たします。以下にその主な機能と使い方を説明します：


- 反復処理：

.each は、配列やレンジ（範囲）の各要素に対して、指定された処理を順番に実行します。

-ブロックとの連携：

.eachは通常、ブロック（{ } や do...end で囲まれたコード）と共に使用されます。各要素に対して、このブロック内の処理が実行されます。

-要素の受け渡し：

ブロック内の |num| のような部分（ブロックパラメータ）に、各要素が順番に渡されます。

-柔軟性：

配列、ハッシュ、範囲など、様々なオブジェクトに対して使用できます。

-戻り値：

.each は処理が終わると元のオブジェクト自体を返します。
```
例えば、(1..1000).each { |num| puts num } の場合：

(1..1000) は 1 から 1000 までの範囲を表します。
.each はこの範囲の各数値に対して処理を行います。
{ |num| puts num } は各数値を出力するという処理を指定しています。

.each を使用することで、明示的なループ（for や while など）を書く必要がなくなり、コードがよりシンプルで読みやすくなります。
```

----------------------------------

## .join

.join メソッド:

これは配列のメソッドで、配列の要素を1つの文字列に連結します。


-引数 ' ':

join メソッドの引数として与えられています。

これは「区切り文字」を指定します。ここでは半角スペースを表しています。


-動作:

配列の各要素を、指定された区切り文字（この場合は半角スペース）で区切りながら連結します。

```
例えば、[8, 1, 3].join(' ') の場合：

配列 [8, 1, 3] の各要素を
半角スペース ' ' で区切りながら
1つの文字列に連結します

結果として "8 1 3" という文字列が生成されます。
```

------------------------------------------


## map ・ collect / map!
mapは、配列の要素の数だけブロック内の処理を繰り返し、結果として作成された配列を返す。

mapは元の値に対して影響を与えないのに対し、map!は元の値を書き換える。また、Rubyにはcollectメソッドがあるが、これはmapメソッドの別名。

mapメソッドを使用した場合
```
array = ["a", "b", "c"]
=> ["a", "b", "c"]
```
```
array.map {|s|  s.upcase }
=> ["A", "B", "C"]
```
```
p array
=> ["a", "b", "c"] # 元の値はそのまま
```

map!メソッドを使用した場合
```
array = ["a", "b", "c"]
=> ["a", "b", "c"]
```
```
array.map {|s|  s.upcase }
=> ["A", "B", "C"]
```
```
p array
=> ["A", "B", "C"] # 元の値が変更されてしまう
```
mapメソッドは、下記の３つの条件に合えば、ブロックを渡す代わりに&:メソッドを使って省略して書くことが出来る。

-ロックの引数が１つであること
-ブロックで呼び出すメソッドに引数がないこと
-ブロック引数に対して、メソッドを呼び出すこと以外の処理がないこと

-通常の書き方
```
["RUBY", "PHP", "JAVA"].map { |s| s.downcase }
=> ['ruby', 'php', 'java']
```

省略した書き方
```
["RUBY", "PHP", "JAVA"].map(&:downcase)
=> ["ruby", "php", "java"]
```
mapメソッドは、配列だけではなくHashに対しても使用することができる。

ただし、返り値はハッシュではなく、配列になるので注意。返り値を配列ではなくHashにする場合は、to_hメソッドを使用。

```
h = { BANANA: 100, ORANGE: 200, MELON: 300 }
=> {BANANA: 100, ORANGE: 200, MELON: 300}
```
```
h.map { |key, value| [key.downcase, value] }
=> [[:banana, 100], [:orange, 200], [:melon, 300]]
```
```
h.map { |key, value| [key.downcase, value] }.to_h
=> {banana: 100, orange: 200, melon: 300}
```
## upto

```
1.upto(N) は以下のような特徴を持っています：

基本的な動作:

開始値（この場合は1）から指定された上限値（N）まで、順番に数値を生成します。
生成された各数値に対して、ブロック内の処理を実行します。


構文:
rubyCopystart_number.upto(end_number) do |i|
  # ブロック内の処理
end

処理の流れ:

最初に i が1になります。
ブロック内の処理を実行します。
i が1増加します。
i がNより大きくなるまで、この処理を繰り返します。


利点:

コードが簡潔で読みやすくなります。
範囲指定が明確で、off-by-oneエラー（境界値の扱いを1つ間違えるエラー）を防ぎやすいです。


他の書き方との比較:

(1..N).each と同じ動作をしますが、より直感的です。
従来の for ループよりもRubyらしい書き方です。


戻り値:

ブロックを与えた場合、upto メソッドは元の数値（この場合は1）を返します。
ブロックを与えなかった場合、Enumeratorオブジェクトを返します。



例えば：
rubyCopy1.upto(5) do |i|
  puts i
end
これは以下のように出力します：
Copy1
2
3
4
5
upto メソッドは、特に1から始まる連続した数値の範囲を扱う際に便利で、Rubyらしい簡潔な記述を可能にします。
```
