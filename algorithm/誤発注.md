C139

あなたは、製品番号 1 番から N 番までの製品がそれぞれ 1 つずつ必要になり、注文しました。

しかし、製品が届いてから不要な製品を注文していたり、同じ製品を複数注文していたりと、誤った注文をしていたことが判明しました。


誤って注文した分は仕方ありませんが、必要な製品が届いていないのは問題です。

あなたは追加で注文をかけるため、必要な製品のうち届いていないものが何種類あるか調べることにしました。

届いた製品の一覧が与えられるので、必要な 1 番から N 番までの製品の中で届いていない製品が何種類あるか出力してください。

入力例 1 の場合、1 番から 5 番までの製品が必要ですが、3, 5 番の製品が注文ミスで届いていません。2 種類不足しているので、2 と出力してください。
```
N
x_1
x_2
...
x_N
・1 行目に必要な製品番号の範囲を表す整数 N が与えられます。
・続く N 行の i 行目 (1 ≦ i ≦ N) には、i 番目に届いた製品の製品番号が与えられます。
・入力は合計で N + 1 行からなり、入力値最終行の末尾に改行が 1 つ入ります。
```
```
それぞれの値は文字列で標準入力から渡されます。標準入力からの値取得方法はこちらをご確認ください
期待する出力
1 番から N 番までの製品の中でまだ届いていない製品が何種類あるか出力してください。
```
```
・期待する出力は 1 行からなります。
・整数で出力してください。
・末尾に改行を入れ、余計な文字、空行を含んではいけません。
```
```
条件
すべてのテストケースにおいて、以下の条件をみたします。

・1 ≦ N ≦ 10,000
・1 ≦ x_i ≦ 100,000 (1 ≦ i ≦ N)
```
```
入力例1
5
1
4
6
2
1
```
```
出力例1
2
```
```
入力例2
3
1
2
3
```
```
出力例2
0
```

-----------------

```
n =gets.to_i
recieved_items = Array.new(n + 1, false)

n.times do
 items = gets.to_i
 recieved_items[items] = true if items <= n
end

missing = (1..n).count { |i|! recieved_items[i] }
puts missing
```

Array.new(n + 1, false) で、サイズが n+1 の新しい配列を作成

すべての要素は初期値として false に設定している
```
recieved_items[items] = true if items <= n
```
この行は、受け取ったアイテム番号（items）が有効範囲内（n以下）の場合、そのアイテムを受け取ったとマークしている
recieved_items[items] は配列の items 番目の要素にアクセスしている

= true でその要素を true に設定し、アイテムが受け取られたことを示す

if items <= n は、アイテム番号が n 以下の場合のみこの操作を行うという条件

```
missing = (1..n).count { |i|! recieved_items[i] }
```

この行は、受け取っていないアイテムの数を数えている

(1..n) は 1 から n までの範囲を作成

.count メソッドは、条件に合う要素の数を数える

{ |i|! recieved_items[i] } はブロックで、各要素 i に対して実行

! recieved_items[i] は、i 番目の要素が false（受け取っていない）の場合に true を返す

つまり、false の要素（受け取っていないアイテム）の数を数えている

```
puts missing
```
最後に、見つかった未受領アイテムの数（missing）を出力します。
