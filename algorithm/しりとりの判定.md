Paiza C144
あなたは生徒にしりとりの課題を出しました。生徒は英字小文字または英字大文字からなる N 個の単語を順に提出します。N 個の単語が与えられた順でしりとりが成立するかどうか判定してください。

ここで、N 個の単語が与えられた順でしりとりが成立するとは、全ての i (1 ≦ i ≦ N-1) において、i 番目の単語の末尾と i+1 番目の単語の先頭が同じ文字となっていることを言います。このとき、小文字と大文字を区別することに注意してください。

しりとりが成立しない場合、初めてしりとりが成立しなかった 2 つの連続する単語の 1 つめの単語の末尾の文字と 2 つめの単語の先頭の文字を出力してください。しりとりが成立する場合は、Yes と出力してください。

入力例 1 の場合、はじめの二つの単語、apPle と error は、apPle の末尾と error の先頭が同じ e であるため、しりとりが成立しています。しかし、続く 2 つの単語 error と suBway は、error の末尾の文字と suBway の先頭の文字が等しくないので、しりとりは成立していません。したがって、期待される出力は r と s になります。

```
評価ポイント
10回のテストケースで、正答率、実行速度、メモリ消費量をはかり得点が決まります。
より早い解答時間で提出したほうが得点が高くなります。
複数のテストケースで正しい出力がされるか評価（+50点）
解答までの速さ評価（+50点）
入力される値
入力は以下のフォーマットで与えられます。
```
```
N
s_1
s_2
...
s_N
・1 行目に入力される単語の数 N が与えられます。
・続く N 行のうちの i 行目 (1 ≦ i ≦ N) には英字小文字および、英字大文字からなる文字列 s_i が与えられます。
・入力は合計で N + 1 行となり、入力値最終行の末尾に改行が 1 つ入ります。
```
```
期待する出力
しりとりが成立する場合、以下の形式で出力してください。
Yes
しりとりが成立しない場合、以下の形式で出力してください。
x y
期待する出力は 1 行からなります。初めてしりとりが成立しなかった 2 つの連続する単語の 1 つ目の単語の末尾の文字を表す英字 x と 2 つ目の単語の先頭の文字を表す英字 y をこの順で半角スペース区切りで出力してください。
末尾に改行を入れ、余計な文字、空行を含んではいけません。
```
```
条件
すべてのテストケースにおいて、以下の条件をみたします。

・2 ≦ N ≦ 1,000
・1 ≦ (s_iの長さ) ≦ 50 (1 ≦ i ≦ N)
・s_i は英字小文字または英字大文字からなる
```
```
入力例1
4
apPle
error
suBway
Zb
```
```
出力例1
r s
```
```
入力例2
5
idIOh
hiKoQA
AbijoD
djgeldi
kjoial
```
```
出力例2
D d
```
```
入力例3
3
adijA
Akq
qZR
```
```
出力例3
Yes
```

------

```
n =gets.to_i
words = n.times.map { gets.chomp }

def shiritori_check(words)
  words.each_cons(2) do |word1, word2|
    if word1[-1].downcase != word2[0].downcase
      return "#{word1[-1]} #{word2[0]}"
    end
  end
  "Yes"
end


puts shiritori_check(words)
```

最初に、単語の数 n を読み込む

次に、n 個の単語を読み込み、配列 words に格納する

※
```
n.times:
```
n回繰り返すイテレータを生成する。nは前の行で読み込んだ整数値

```
.map:
```
各繰り返しに対して新しい要素を生成し、それらを集めた配列を返すメソッド

```
gets:
```
標準入力から1行を読み込む
```
.chomp:
```
文字列の末尾から改行文字（\n）を削除する

```
{ ... }:
```
ブロックを定義し、この中の処理が各繰り返しで実行される

shiritori_check 関数は、単語のリストを受け取り、しりとりが成立するかをチェックします。
```
n.times do |i|
```
n回ループを実行する。iは0からn-1までの現在のインデックスを指す

```
next if i == 0
```
前の単語との比較が不要なため、最初の単語（i=0）はスキップする

```
if words[i-1][-1].downcase != words[i][0].downcase

words[i-1][-1]: 前の単語の最後の文字
words[i][0]: 現在の単語の最初の文字
.downcase: 大文字小文字を区別せずに比較するために小文字に変換
```
これらが一致しない場合、以下のブロックを実行
```

puts "#{words[i-1][-1]} #{words[i][0]}"
```
しりとりが成立しなかった場合、不一致の2文字を出力





